<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/iron-ajax/iron-ajax.html">
<link rel="import" href="../bower_components/paper-item/paper-item.html">
<link rel="import" href="../bower_components/paper-item/paper-item.html">
<link rel="import" href="../bower_components/paper-input/paper-input.html">
<!--
<link rel="import" href="../bower_components/core-label/core-label.html">
-->
<link rel="import" href="../bower_components/paper-ripple/paper-ripple.html">
<link rel="import" href="../bower_components/iron-collapse/iron-collapse.html">
<link rel="import" href="../bower_components/paper-checkbox/paper-checkbox.html">
<link rel="import" href="../bower_components/paper-dropdown-menu/paper-dropdown-menu.html">
<link rel="import" href="../bower_components/iron-dropdown/iron-dropdown.html">
<link rel="import" href="../bower_components/paper-toggle-button/paper-toggle-button.html">

  <link rel="import" href="../bower_components/iron-flex-layout/iron-flex-layout.html">
<dom-module id="g-layercatalogus">
  <style>
    /* TODO(polyup): For speed, consider reworking these styles with .classes
                     and #ids rather than [attributes].
    */
    [fit] {
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
    }
  </style>
  <style>
.layerItem{
    min-height:30px;
}
.group {
    margin-left:-20px;
    min-width: 350px;
    margin-right:-20px;
}
.group iron-collapse {
    padding-left:2px;
    padding-right: 10px;
}
iron-item {
    cursor:pointer;
    word-wrap: normal
}
iron-collapse {
    background: rgba(225,225,230,0.4);
    -webkit-box-shadow: inset 0px 2px 5px 0px rgba(161,161,161,0.62);
    -moz-box-shadow: inset 0px 2px 5px 0px rgba(161,161,161,0.62);
    box-shadow: inset 0px 2px 5px 0px rgba(161,161,161,0.62);
}
#zoekVeld {
    width: 300px;
}
paper-dropdown-menu,paper-dropdown {
    width: 220px;
}
</style>
  <template>
<iron-ajax id="getConfig" auto="" url="../config.json" handeas="json" on-response="initialConfig"></iron-ajax>
<iron-ajax
  auto
  url="{{url}}"
  verbose="true"
  with-credentials="true"
  on-response="handleResponse"
  id="getConfig"></iron-ajax>
    <paper-input id="zoekVeld" value="{{searchString::input}}" label="Zoek een laag"></paper-input>
    <template is="dom-repeat" items="{{catalogus}}" as="layer" id="layerList" filter="{{computeFilter(searchString)}}">
    <paper-item class="layer" on-click="toggleLayer"><iron-icon icon$="{{_computeIcon(layer.options.visibility)}}"  item-icon></iron-icon>{{layer.options.config.title}}<paper-ripple fit=""></paper-ripple></paper-item>
    </template>
    <array-selector id="selector" items="{{catalogus}}" selected="{{activelayers}}" multi toggle></array-selector>
    <template is="dom-repeat" items="{{activelayers}}">
      <div>Selected: <span>{{item.options.config.title}}</span></div>
    </template>
</template>
</template>
  <script>
    Polymer({
      is: 'g-layercatalogus',
      computeFilter: function(string) {
        if (!string) {
          // set filter to null to disable filtering
          return null;
        } else {
          // return a filter function for the current search string
          string = string.toLowerCase();
          return function(layer) {
            var title = layer.options.config.title.toLowerCase();
           
            return (title.indexOf(string) != -1 );
          };
        }
      },
      properties: {
        account: {
          notify: true,
          observer: 'accountChanged'
        },
        catalogus: {
          type: Array,
          value: function(){
            return [];
          }
        },
        docurl: {
          type: String,
          value: 'https://services.geodan.nl/document/api'
        },
        filters: { notify: true },
        mapType: { notify: true },
        search: { observer: 'searchChanged' },
        url: String
      },
      observers: [
        'layersChanged(activelayers.*)'
      ],
      layersChanged: function(e){
        if(e && e.path&& e.path.split('.').length >1 && e.path.split('.')[1].indexOf('#') >= 0) {
   /*      this.updateCatalogus(this.layers);
         this.$$('#layerList').render()*/
        }
      },
      //Walk through the layers to find those matching the search string
      //and update the visible list in the element
      searchChanged: function () {
        var zoek = this.search;
        var resultaat = this.layers.filter(function (l) {
          return l.options.config.title.toLowerCase().indexOf(zoek.toLowerCase()) >= 0;
        });
        var open = zoek == '' ? false : true;
        //to make sure all core-collapse are open when searching
        this.updateCatalogus(resultaat, open);
      },
      initialConfig: function (d) {
        var response = d.detail.response;
        this.config = response;
      },
      //Once an GeodanMaps account is acquired it will set the url to request the list of configurations
      //from the document service.
      accountChanged: function () {
        if (this.account.OrganisationCode) {
          this.set('$.getConfig.url', this.docurl + '/' + this.account.OrganisationCode + '/config/');
        }
      },
      //The response from the document service will be parsed here.
      handleResponse: function (d) {
      if(d.detail&&d.detail.xhr&&d.detail.xhr.response) {
        var response = d.detail.xhr.response;
        if (response.constructor === Array) {
          //just a list of configs
          this.configs = response;
          //TODO: choose which configuration is used (currently the first)
          this.set('$.getConfig.url', this.docurl + '/data/' + this.account.OrganisationCode + '/config/' + this.config.name);
          this.activeConfig = this.config.title;
        } else {
          //actual config
          var layerset = response.map.layers;
          var resolutions = response.map.view.resolutions;
          //Leaflet needs zoomlevels to set min/max scalelevel
          var calcZoom = function (scale) {
            var res = 0.28 * scale / 1000;
            //standard geoserver scale calculation
            var zoom = 0;
            for (var i = 0; i < resolutions.length; i++) {
              if (res < resolutions[i])
                zoom++;
            }
            return zoom;
          };
          //Parse the GeodanMaps layerset into a set of Leaflet layers
          var makeLeaflet = function (configLayer) {
            var tmplayers = []
            var minZoom = 0;
            if (configLayer.options.maxResolution) {
              minZoom = calcZoom(configLayer.options.maxResolution);
            }
            //add a convenience attribute for filterable layers (used by g-filtermanager)
            if (configLayer.filters) {
              configLayer.isFilter = true;
            }
            var l;
            //create leaflet objects, depending on the layer-type
            switch (configLayer.source.type) {
            case 'OGC_WMS':
              l = L.tileLayer.wms(configLayer.source.url, {
                layers: configLayer.source.featureName,
                format: configLayer.source.contenttype ? configLayer.source.contenttype : 'image/png',
                transparent: configLayer.options.transparent,
                opacity: configLayer.options.opacity,
                visibility: configLayer.options.visible,
                config: configLayer,
                minZoom: minZoom
              });
              break;
            }
            return l;
          };
          switch (this.mapType) {
          case 'leaflet':
            tmplayers = layerset.map(makeLeaflet).splice(1,5);
            break;
          default:
            tmplayers = layerset.map(makeLeaflet);
            break;
          }
          var self = this;
          tmplayers.forEach(function(layer){
            self.push('layers',layer);
          })
          this.parseLayers(this.layers);
        }
      }
      },
      //Create the layercatalogus and set the filters and activelayers (visible in the g-layermanager)
      //attributes that need to change when loading or changing a config should be set here
      parseLayers: function (layerlist, open) {
        var self = this;
        this.updateCatalogus(layerlist, open);
    /*    this.filters = layerlist.filter(function (l) {
          return l.options.config.filters;
        });
        var tmplist = layerlist.filter(function (l) {
          return l.options.visibility;
        });
        tmplist.forEach(function(item) {
          self.push('activelayers',item);
        })*/
      },
      //Update the catalogus-tree after a config-change or search-change
      updateCatalogus: function (layerlist, open) {
        //the layerlist is a flat list with .groupName and .subgroupName attributes
        //it needs to be changed into a tree structure with group>subgroup>layer
        //or group>layer nodes
        var catId = 0;
        var self = this;
        //this.splice('catalogus',0,this.catalogus.length);
        var catalogus = layerlist.reduce(function (a, l) {
          if (l.options.config.filters && l.options.config.filters.length > 0) {
            //exclude filterabe layers form the catalogus
            //TODO: make this configurable??
            return a;
          }
          else {
            a.push(l);
            return a
          }
      /*    l.options.catid = catId++;
          var group = a.filter(function (d) {
            return d.group == l.options.config.groupName;
          });
          if (group.length == 0) {
            //create group
            if (l.options.config.subgroupName) {
              //create subgroup and add layer
              a.push({
                group: l.options.config.groupName,
                opened: open,
                layers: [],
                subgroup: [{
                    subname: l.options.config.subgroupName,
                    opened: open,
                    layers: [l]
                  }]
              });
            } else {
              //layer isn't in a subgroup: add layer to group
              a.push({
                group: l.options.config.groupName,
                opened: open,
                subgroup: [],
                layers: [l]
              });
            }
          } else {
            if (l.options.config.subgroupName) {
              var sub = group[0].subgroup.filter(function (d) {
                return d.subname == l.options.config.subgroupName;
              });
              if (sub.length == 0) {
                //create subgroup and add layer
                group[0].subgroup.push({
                  subname: l.options.config.subgroupName,
                  opened: open,
                  layers: [l]
                });
              } else {
                //add layer to subgroup
                sub[0].layers.push(l);
              }
            } else {
              //layer isn't in a subgroup: add layer to group
              group[0].layers.push(l);
            }
          }
          return a;*/
        }, []);
        catalogus.forEach(function(item){
          self.push('catalogus',item);
        })
      },
      //open/close core-collapses
      toggle: function (e) {
        e.target.icon = e.target.icon == 'arrow-drop-down' ? 'arrow-drop-up' : 'arrow-drop-down';
        //TODO: polymer.dom
        e.target.nextElementSibling.toggle();
      },
      //workaround for nested core-collapses
      resizeGroup: function (e) {
        //TODO: polymer.dom
        var el = e.target.parentElement.parentElement;
        setTimeout(function () {
          el.transitionEnd();
        }, 330);
      },
      //add/remove layer to the activelayers list
      toggleLayer: function (e) {
        var item = this.$.layerList.itemForElement(e.target);
        e.model.set('layer.options.visibility',item.options.visibility?false:true);
         this.$.selector.select(item);

        /*var layer = e.model.layer;
        var vis = layer.options.visibility ? false : true;
         var path = 'layer.options.visibility';
        e.model.set(path,vis);
        
        if(layer.options.visibility ){          
          this.push('activelayers',layer) 
          console.log('activelayers.#'+this.activelayers.indexOf(layer)+'.options.visibility');
          e.model.linkPaths(path,'activelayers.#'+this.activelayers.indexOf(layer)+'.options.visibility');
        }
        else { 
          e.model.unlinkPaths(path);
          this.splice('activelayers',this.activelayers.indexOf(layer), 1);
          
        }
        */
      },
      ready: function () {
        window.debugthis = this;
        this.config = {};
        this.mapType = this.mapType || 'leaflet';
        this.layers = this.layers || [];
        this.filters = this.filters || [];
       // this.catalogus = this.catalogus || [];
        this.account = this.account || {};
        this.configs = [];
        this.activeConfig = '';
      },
      _computeIf: function (account, undefined) {
        return account.ID == undefined;
      },
      _computeIf2: function (account, undefined) {
        return account.ID != undefined;
      },
      _computeLabel: function (layer) {
        return layer.group == null ? 'Generiek' : layer.group;
      },
      _computeIcon: function (l) {
        console.log('compute');
        return l ? 'check-box' : 'check-box-outline-blank';
      }
    });
  </script>
</dom-module>
