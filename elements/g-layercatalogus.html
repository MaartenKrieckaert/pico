<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/iron-ajax/iron-ajax.html">
<link rel="import" href="../bower_components/paper-item/paper-item.html">
<link rel="import" href="../bower_components/paper-item/paper-item.html">
<link rel="import" href="../bower_components/paper-input/paper-input.html">
<!--
<link rel="import" href="../bower_components/core-label/core-label.html">
-->
<link rel="import" href="../bower_components/paper-ripple/paper-ripple.html">
<link rel="import" href="../bower_components/iron-collapse/iron-collapse.html">
<link rel="import" href="../bower_components/paper-checkbox/paper-checkbox.html">
<link rel="import" href="../bower_components/paper-dropdown-menu/paper-dropdown-menu.html">
<link rel="import" href="../bower_components/iron-dropdown/iron-dropdown.html">
<link rel="import" href="../bower_components/paper-toggle-button/paper-toggle-button.html">

  <link rel="import" href="../bower_components/iron-flex-layout/iron-flex-layout.html">
<dom-module id="g-layercatalogus">
  <style>
    /* TODO(polyup): For speed, consider reworking these styles with .classes
                     and #ids rather than [attributes].
    */
    [fit] {
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
    }
  </style>
  <style>
.layerItem{
    min-height:30px;
}
.group {
    margin-left:-20px;
    min-width: 350px;
    margin-right:-20px;
}
.group iron-collapse {
    padding-left:2px;
    padding-right: 10px;
}
iron-item {
    cursor:pointer;
    word-wrap: normal
}
iron-collapse {
    background: rgba(225,225,230,0.4);
    -webkit-box-shadow: inset 0px 2px 5px 0px rgba(161,161,161,0.62);
    -moz-box-shadow: inset 0px 2px 5px 0px rgba(161,161,161,0.62);
    box-shadow: inset 0px 2px 5px 0px rgba(161,161,161,0.62);
}
#zoekVeld {
    width: 300px;
}
paper-dropdown-menu,paper-dropdown {
    width: 220px;
}
</style>
  <template>
<iron-ajax id="getConfig" auto="" url="../config.json" handeas="json" on-response="initialConfig"></iron-ajax>
<iron-ajax
  auto
  url="{{url}}"
  verbose="true"
  with-credentials="true"
  on-response="handleResponse"
  id="getConfig"></iron-ajax>
<template is="dom-if" if="{{_computeIf(account, undefined)}}">
    <p>U bent niet ingelogd, dus er zijn geen lagen beschikbaar.</p>
</template>
<template is="dom-if" if="{{_computeIf2(account)}}">
    <paper-input id="zoekVeld" value="{{search}}" label="Zoek een laag"></paper-input>
    <template is="dom-repeat" items="{{catalogus}}" as="layer" id="layerList">
    <div class="group"><paper-item class="groupTitle" on-click="toggle">{{_computeLabel(layer)}}<paper-ripple fit=""></paper-ripple></paper-item>
        <iron-collapse opened="{{layer.opened}}">
            <template is="dom-repeat" items="{{layer.subgroup}}" as="sub">
            <div class="subGroup"><paper-item class="subGroupTitle" on-click="toggle"><paper-ripple fit="">{{sub.subname}}</paper-ripple></paper-item>
                <iron-collapse on-core-collapse-open="resizeGroup" opened="{{sub.opened}}">
                <template is="dom-repeat" items="{{sub.layers}}" as="l">
               <paper-item class="layer" vis="{{l.options.visibility}}" on-click="{{_computeIcon(l)}}">{{l.options.config.title}}<paper-ripple fit=""></paper-ripple></paper-item>
                </template>
                </iron-collapse>
            </div>
            </template>
            <template is="dom-repeat" items="{{layer.layers}}" as="l">
                 <paper-item class="layer" vis="{{l.options.visibility}}" on-click="toggleLayer">{{l.options.config.title}}<paper-ripple fit=""></paper-ripple></paper-item>
            </template>
        </iron-collapse>
    </div>
    </template>
</template>
</template>
  <script>
    Polymer({
      is: 'g-layercatalogus',
      properties: {
        account: {
          notify: true,
          observer: 'accountChanged'
        },
        activeLayers: { notify: true },
        docurl: {
          type: String,
          value: 'https://services.geodan.nl/document/api'
        },
        filters: { notify: true },
        mapType: { notify: true },
        search: { observer: 'searchChanged' }
      },
      //Walk through the layers to find those matching the search string
      //and update the visible list in the element
      searchChanged: function () {
        var zoek = this.search;
        var resultaat = this.layers.filter(function (l) {
          return l.options.config.title.toLowerCase().indexOf(zoek.toLowerCase()) >= 0;
        });
        var open = zoek == '' ? false : true;
        //to make sure all core-collapse are open when searching
        this.updateCatalogus(resultaat, open);
      },
      initialConfig: function (d) {
        var response = d.detail.response;
        this.config = response;
      },
      //Once an GeodanMaps account is acquired it will set the url to request the list of configurations
      //from the document service.
      accountChanged: function () {
        if (this.account.OrganisationCode) {
          this.set('$.getConfig.url', this.docurl + '/' + this.account.OrganisationCode + '/config/');
        }
      },
      //The response from the document service will be parsed here.
      handleResponse: function (d) {
      if(d.detail&&d.detail.xhr&&d.detail.xhr.response) {
        var response = d.detail.xhr.response;      
        if (response.constructor === Array) {
          //just a list of configs
          this.configs = response;
          //TODO: choose which configuration is used (currently the first)
          this.set('$.getConfig.url', this.docurl + '/data/' + this.account.OrganisationCode + '/config/' + this.config.name);
          this.activeConfig = this.config.title;
        } else {
          //actual config
          var layerset = response.map.layers;
          var resolutions = response.map.view.resolutions;
          //Leaflet needs zoomlevels to set min/max scalelevel
          var calcZoom = function (scale) {
            var res = 0.28 * scale / 1000;
            //standard geoserver scale calculation
            var zoom = 0;
            for (var i = 0; i < resolutions.length; i++) {
              if (res < resolutions[i])
                zoom++;
            }
            return zoom;
          };
          //Parse the GeodanMaps layerset into a set of Leaflet layers
          var makeLeaflet = function (configLayer) {
            var minZoom = 0;
            if (configLayer.options.maxResolution) {
              minZoom = calcZoom(configLayer.options.maxResolution);
            }
            //add a convenience attribute for filterable layers (used by g-filtermanager)
            if (configLayer.filters) {
              configLayer.isFilter = true;
            }
            var l;
            //create leaflet objects, depending on the layer-type
            switch (configLayer.source.type) {
            case 'OGC_WMS':
              l = L.tileLayer.wms(configLayer.source.url, {
                layers: configLayer.source.featureName,
                format: configLayer.source.contenttype ? configLayer.source.contenttype : 'image/png',
                transparent: configLayer.options.transparent,
                opacity: configLayer.options.opacity,
                visibility: configLayer.options.visible,
                config: configLayer,
                minZoom: minZoom
              });
              break;
            }
            return l;
          };
          switch (this.mapType) {
          case 'leaflet':
            this.layers = layerset.map(makeLeaflet);
            break;
          default:
            this.layers = layerset.map(makeLeaflet);
            break;
          }
          this.parseLayers(this.layers);
        }
      }
      },
      //Create the layercatalogus and set the filters and activeLayers (visible in the g-layermanager)
      //attributes that need to change when loading or changing a config should be set here
      parseLayers: function (layerlist, open) {
        this.updateCatalogus(layerlist, open);
        this.filters = layerlist.filter(function (l) {
          return l.options.config.filters;
        });
        this.activeLayers = layerlist.filter(function (l) {
          return l.options.visibility;
        });
      },
      //Update the catalogus-tree after a config-change or search-change
      updateCatalogus: function (layerlist, open) {
        //the layerlist is a flat list with .groupName and .subgroupName attributes
        //it needs to be changed into a tree structure with group>subgroup>layer
        //or group>layer nodes
        this.catalogus = layerlist.reduce(function (a, l) {
          if (l.options.config.filters && l.options.config.filters.length > 0) {
            //exclude filterabe layers form the catalogus
            //TODO: make this configurable??
            return a;
          }
          var group = a.filter(function (d) {
            return d.group == l.options.config.groupName;
          });
          if (group.length == 0) {
            //create group
            if (l.options.config.subgroupName) {
              //create subgroup and add layer
              a.push({
                group: l.options.config.groupName,
                opened: open,
                layers: [],
                subgroup: [{
                    subname: l.options.config.subgroupName,
                    opened: open,
                    layers: [l]
                  }]
              });
            } else {
              //layer isn't in a subgroup: add layer to group
              a.push({
                group: l.options.config.groupName,
                opened: open,
                subgroup: [],
                layers: [l]
              });
            }
          } else {
            if (l.options.config.subgroupName) {
              var sub = group[0].subgroup.filter(function (d) {
                return d.subname == l.options.config.subgroupName;
              });
              if (sub.length == 0) {
                //create subgroup and add layer
                group[0].subgroup.push({
                  subname: l.options.config.subgroupName,
                  opened: open,
                  layers: [l]
                });
              } else {
                //add layer to subgroup
                sub[0].layers.push(l);
              }
            } else {
              //layer isn't in a subgroup: add layer to group
              group[0].layers.push(l);
            }
          }
          return a;
        }, []);
      },
      //open/close core-collapses
      toggle: function (e) {
        e.target.icon = e.target.icon == 'arrow-drop-down' ? 'arrow-drop-up' : 'arrow-drop-down';
        e.target.nextElementSibling.toggle();
      },
      //workaround for nested core-collapses
      resizeGroup: function (e) {
        var el = e.target.parentElement.parentElement;
        setTimeout(function () {
          el.transitionEnd();
        }, 330);
      },
      //add/remove layer to the activeLayers list
      toggleLayer: function (e) {
        var layer = e.model.l;
        //replace undefined with false
        layer.options.visibility = layer.options.visibility ? false : true;
        layer.options.visibility ? this.activeLayers.push(layer) : this.activeLayers.splice(this.activeLayers.indexOf(layer), 1);
      },
      ready: function () {
        this.config = {};
        this.mapType = this.mapType || 'leaflet';
        this.layers = this.layers || [];
        this.filters = this.filters || [];
        this.catalogus = this.catalogus || [];
        this.activeLayers = this.activeLayers || [];
        this.account = this.account || {};
        this.configs = [];
        this.activeConfig = '';
      },
      _computeIf: function (account, undefined) {
        return account.ID == undefined;
      },
      _computeIf2: function (account, undefined) {
        return account.ID != undefined;
      },
      _computeLabel: function (layer) {        
        return layer.group == null ? 'Generiek' : layer.group;
      },
      _computeIcon: function (l) {
        return l.options.visibility ? 'check-box' : 'check-box-outline-blank';
      }
    });
  </script>
</dom-module>
