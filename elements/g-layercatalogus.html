<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/iron-ajax/iron-ajax.html">
<link rel="import" href="../bower_components/paper-item/paper-item.html">
<link rel="import" href="../bower_components/paper-item/paper-item.html">
<link rel="import" href="../bower_components/paper-input/paper-input.html">
<!--
<link rel="import" href="../bower_components/core-label/core-label.html">
-->
<link rel="import" href="../bower_components/paper-ripple/paper-ripple.html">
<link rel="import" href="../bower_components/iron-collapse/iron-collapse.html">
<link rel="import" href="../bower_components/paper-checkbox/paper-checkbox.html">
<link rel="import" href="../bower_components/paper-dropdown-menu/paper-dropdown-menu.html">
<link rel="import" href="../bower_components/iron-dropdown/iron-dropdown.html">
<link rel="import" href="../bower_components/paper-toggle-button/paper-toggle-button.html">

  <link rel="import" href="../bower_components/iron-flex-layout/iron-flex-layout.html">
<dom-module id="g-layercatalogus">
  <style>
.layerItem{
    min-height:30px;
}
.group {
    margin-left:-20px;
    min-width: 350px;
    margin-right:-20px;
}
.group iron-collapse {
    padding-left:2px;
    padding-right: 10px;
}
iron-item {
    cursor:pointer;
    word-wrap: normal
}
iron-collapse {
    background: rgba(225,225,230,0.4);
    -webkit-box-shadow: inset 0px 2px 5px 0px rgba(161,161,161,0.62);
    -moz-box-shadow: inset 0px 2px 5px 0px rgba(161,161,161,0.62);
    box-shadow: inset 0px 2px 5px 0px rgba(161,161,161,0.62);
}
#zoekVeld {
    width: 300px;
}
paper-dropdown-menu,paper-dropdown {
    width: 220px;
}
</style>
  <template>
<iron-ajax id="getConfig" auto="" url="../config.json" handeas="json" on-response="initialConfig"></iron-ajax>
<iron-ajax
  auto
  url="{{url}}"
  verbose="true"
  with-credentials="true"
  on-response="handleResponse"
  id="getConfig"></iron-ajax>
<template is="dom-if" if="{{_computeIf(account)}}">
    <p>U bent niet ingelogd, dus er zijn geen lagen beschikbaar.</p>
</template>

<template is="dom-if" if="{{_computeIf2(account)}}">
    <paper-input id="zoekVeld" value="{{search}}" label="Zoek een laag"></paper-input>
    <template is="dom-repeat" items="{{catalogus}}" as="group" id="layerList">
    <div class="group"><paper-item class="groupTitle" on-click="toggle">{{_computeLabel(group)}}</paper-item>
        <iron-collapse opened="{{group.opened}}">
            <template is="dom-repeat" items="{{group.subgroup}}" as="sub" id="layerList">
              <div class="subgroup"><paper-item class="groupTitle" on-click="toggle">{{sub.subname}}</paper-item>
               <iron-collapse opened="{{subgroup.opened}}">
                <template class='repeater' is="dom-repeat" items="{{layers}}" as="l" idx="{{index}}" filter="{{layersubfilter(sub.subname,sub)}}">
                
                   <paper-item class="layer" on-click="toggleLayer"><iron-icon icon$="{{_computeIcon(l.options.visibility)}}"  item-icon></iron-icon>{{l.options.config.title}}<paper-ripple></paper-ripple></paper-item>
               
                </template>
                  </iron-collapse>
              </div>
            </template>
            
           
            <!-- temporarily no subgroups
            <template is="dom-repeat" items="{{layer.subgroup}}" as="sub">
            <div class="subGroup"><paper-item class="subGroupTitle" on-click="toggle">{{sub.subname}}<paper-ripple fit=""></paper-ripple></paper-item>
                <iron-collapse on-core-collapse-open="resizeGroup" opened="{{sub.opened}}">
                <template is="dom-repeat" items="{{sub.layers}}" as="l" filter={{visiblelayers()}} observer="options.visibility">
               <paper-item class="layer" on-click="toggleLayer"><paper-checkbox checked="{{l.options.visibility}}" on-click="toggleLayer" style='padding:20px'></paper-checkbox>{{l.options.config.title}}<paper-ripple fit=""></paper-ripple></paper-item>
                </template>
                </iron-collapse>
            </div>
            </template>
            -->
            <template class='repeater' is="dom-repeat" items="{{layers}}" as="l" idx="{{index}}" filter="{{layerfilter(group.group)}}">
                 <paper-item class="layer" on-click="toggleLayer"><iron-icon icon$="{{_computeIcon(l.options.visibility)}}"  item-icon></iron-icon>{{l.options.config.title}}<paper-ripple></paper-ripple></paper-item>
            </template>
        </iron-collapse>
    </div>
    </template>
</template>
</template>
  <script>
    Polymer({
      is: 'g-layercatalogus',
      properties: {
        account: {
          notify: true,
          observer: 'accountChanged'
        },
        activelayers: {
          notify: true

        },
        layers: {
            type: Array,
            value: function(){return []}
        },
        docurl: {
          type: String,
          value: 'https://services.geodan.nl/document/api'
        },
        filters: { notify: true },
        mapType: { notify: true },
        search: { observer: 'searchChanged' },
        url: String
      },
      observers: [
        'layersChanged(activelayers.*)'
      ],
      layerfilter: function(groupname){
          return function(layer){
              if(!layer.options.config.subgroupName)
              return layer.options.config.groupName == groupname;
          };
      },
      layersubfilter: function(subgroupName){
          return function(layer){
              return layer.options.config.subgroupName == subgroupName;
          };
      },
      layersChanged: function(e){
        console.log(e.path, e.value);
        var layer = e.base[0];
        var idx = this.layers.indexOf(layer);
        var path = 'layers.'+idx+'.options.visibility';
        this.set(path,e.value);
        /*
        if(e && e.path&& e.path.split('.').length >1 && e.path.split('.')[1].indexOf('#') >= 0) {
         this.set(e.path,e.value);
        }*/
      },
      //Walk through the layers to find those matching the search string
      //and update the visible list in the element
      searchChanged: function () {
        var zoek = this.search;
        var resultaat = this.layers.filter(function (l) {
          return l.options.config.title.toLowerCase().indexOf(zoek.toLowerCase()) >= 0;
        });
        var open = zoek == '' ? false : true;
        //to make sure all core-collapse are open when searching
        this.updateCatalogus(resultaat, open);
      },
      initialConfig: function (d) {
        var response = d.detail.response;
        this.config = response;
      },
      //Once an GeodanMaps account is acquired it will set the url to request the list of configurations
      //from the document service.
      accountChanged: function () {
        if (this.account.OrganisationCode) {
          this.set('$.getConfig.url', this.docurl + '/' + this.account.OrganisationCode + '/config/');
        }
      },
      //The response from the document service will be parsed here.
      handleResponse: function (d) {
      if(d.detail&&d.detail.xhr&&d.detail.xhr.response) {
        var response = d.detail.xhr.response;
        if (response.constructor === Array) {
          //just a list of configs
          this.configs = response;
          //TODO: choose which configuration is used (currently the first)
          this.set('$.getConfig.url', this.docurl + '/data/' + this.account.OrganisationCode + '/config/' + this.config.name);
          this.activeConfig = this.config.title;
        } else {
          //actual config
          var layerset = response.map.layers;
          var resolutions = response.map.view.resolutions;
          //Leaflet needs zoomlevels to set min/max scalelevel
          var calcZoom = function (scale) {
            var res = 0.28 * scale / 1000;
            //standard geoserver scale calculation
            var zoom = 0;
            for (var i = 0; i < resolutions.length; i++) {
              if (res < resolutions[i])
                zoom++;
            }
            return zoom;
          };
          //Parse the GeodanMaps layerset into a set of Leaflet layers
          var makeLeaflet = function (configLayer) {
            var minZoom = 0;
            if (configLayer.options.maxResolution) {
              minZoom = calcZoom(configLayer.options.maxResolution);
            }
            //add a convenience attribute for filterable layers (used by g-filtermanager)
            if (configLayer.filters) {
              configLayer.isFilter = true;
            }
            var l;
            //create leaflet objects, depending on the layer-type
            switch (configLayer.source.type) {
            case 'OGC_WMS':
              l = L.tileLayer.wms(configLayer.source.url, {
                layers: configLayer.source.featureName,
                format: configLayer.source.contenttype ? configLayer.source.contenttype : 'image/png',
                transparent: configLayer.options.transparent,
                opacity: configLayer.options.opacity,
                visibility: configLayer.options.visible,
                config: configLayer,
                minZoom: minZoom
              });
              break;
            }
            return l;
          };
          switch (this.mapType) {
          case 'leaflet':
            this.layers = layerset.map(makeLeaflet);
            break;
          default:
            this.layers = layerset.map(makeLeaflet);
            break;
          }
          this.parseLayers(this.layers);
        }
      }
      },
      //Create the layercatalogus and set the filters and activelayers (visible in the g-layermanager)
      //attributes that need to change when loading or changing a config should be set here
      parseLayers: function (layerlist, open) {
        var self = this;
        this.updateCatalogus(layerlist, open);
        this.filters = layerlist.filter(function (l) {
          return l.options.config.filters;
        });
        var tmplist = layerlist.filter(function (l) {
          return l.options.visibility;
        });
        tmplist.forEach(function(item) {
          self.push('activelayers',item);
        })
      },
      //Update the catalogus-tree after a config-change or search-change
      updateCatalogus: function (layerlist, open) {
        //the layerlist is a flat list with .groupName and .subgroupName attributes
        //it needs to be changed into a tree structure with group>subgroup>layer
        //or group>layer nodes
        var catId = 0;
        var self = this;
        var catalogus = layerlist.reduce(function (a, l) {
          if (l.options.config.filters && l.options.config.filters.length > 0) {
            //exclude filterabe layers form the catalogus
            //TODO: make this configurable??
            return a;
          }
          l.options.catid = catId++;
          var group = a.filter(function (d) {
            return d.group == l.options.config.groupName;
          });
          if (group.length == 0) {
            //create group
            if (l.options.config.subgroupName) {
              //create subgroup and add layer
              a.push({
                group: l.options.config.groupName,
                opened: open,
                layers: [],
                subgroup: [{
                    subname: l.options.config.subgroupName,
                    opened: open,
                    layers: [l]
                  }]
              });
            } else {
              //layer isn't in a subgroup: add layer to group
              a.push({
                group: l.options.config.groupName,
                opened: open,
                subgroup: [],
                layers: [l]
              });
            }
          } else {
            if (l.options.config.subgroupName) {
              var sub = group[0].subgroup.filter(function (d) {
                return d.subname == l.options.config.subgroupName;
              });
              if (sub.length == 0) {
                //create subgroup and add layer
                group[0].subgroup.push({
                  subname: l.options.config.subgroupName,
                  opened: open,
                  layers: [l]
                });
              } else {
                //add layer to subgroup
                sub[0].layers.push(l);
              }
            } else {
              //layer isn't in a subgroup: add layer to group
              group[0].layers.push(l);
            }
          }
          return a;
        }, []);
        catalogus.forEach(function(item){
          self.push('catalogus',item);
        })
      },
      //open/close core-collapses
      toggle: function (e) {
        e.target.icon = e.target.icon == 'arrow-drop-down' ? 'arrow-drop-up' : 'arrow-drop-down';
        e.target.nextElementSibling.toggle();
      },
      //workaround for nested core-collapses
      resizeGroup: function (e) {
        var el = e.target.parentElement.parentElement;
        setTimeout(function () {
          el.transitionEnd();
        }, 330);
      },
      //add/remove layer to the activelayers list
      toggleLayer: function (e) {
        var layer = e.model.l;
        //replace undefined with false
        var vis = layer.options.visibility ? false : true;
        var idx = this.layers.indexOf(layer);
        var path = 'layers.'+idx+'.options.visibility';
        //console.log(path);
        this.set(path,vis);

        if(layer.options.visibility ){
          this.push('activelayers',layer)
        }
        else {
          this.splice('activelayers',this.activelayers.indexOf(layer), 1);
        }

      },
      ready: function () {
        window.debugthis = this;
        this.config = {};
        this.mapType = this.mapType || 'leaflet';
        this.layers = this.layers || [];
        this.filters = this.filters || [];
        this.catalogus = this.catalogus || [];
        this.account = this.account || {};
        this.configs = [];
        this.activeConfig = '';
      },
      _computeIf: function (account, undefined) {
        return account.ID == undefined;
      },
      _computeIf2: function (account, undefined) {
        return account.ID != undefined;
      },
      _computeLabel: function (layer) {
        return layer.group == null ? 'Generiek' : layer.group;
      },
      _computeIcon: function (l) {
        return l ? 'check-box' : 'check-box-outline-blank';
      }
    });
  </script>
</dom-module>
